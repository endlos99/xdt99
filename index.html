<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="xdt99 : TI 99 Cross-Development Tools">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>xdt99</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/endlos99/xdt99">View on GitHub</a>

          <h1 id="project_title">xdt99</h1>
          <h2 id="project_tagline">TI 99 Cross-Development Tools</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/endlos99/xdt99/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/endlos99/xdt99/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="xdt99-ti-99-cross-development-tools" class="anchor" href="#xdt99-ti-99-cross-development-tools" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>xdt99: TI 99 Cross-Development Tools</h1>

<h1>xdt99: TI 99 Cross-Development Tools</h1>

<p>The <strong>TI 99 Cross-Development Tools</strong> (xdt99) are a small suite of programs that
facilitate the development of programs for the TI 99 family of home computers on
modern computer systems.</p>

<p>As of this release, the cross-development tools comprise</p>

<ul>
<li><code>xas99</code>, a TMS9900 cross-assembler,</li>
<li><code>xga99</code>, a GPL cross-assembler,</li>
<li><code>xda99</code>, a TMS9900 disassembler,</li>
<li><code>xdg99</code>, a GPL disassembler,</li>
<li><code>xbas99</code>, a TI BASIC and TI Extended BASIC lister and encoder,</li>
<li><code>xdm99</code>, a disk manager for sector-based TI disk images,</li>
<li><code>xhm99</code>, a manager for HFE images used by HxC floppy emulators, and</li>
<li><code>xvm99</code>, a volume manager for nanoPEB/CF7+ Compact Flash cards.</li>
</ul>

<p>All programs are written in Python and thus run on any platform that Python
supports, including Linux, Windows, and OS X.</p>

<p>Additionally, xdt99 provides TI-specific editor support for some freely
available cross-platform development environments:</p>

<ul>
<li><code>xdt99-mode</code>, a major mode for the GNU Emacs text editor, and</li>
<li><code>xdt99 IDEA</code>, a plugin for the IntelliJ IDEA development environment.</li>
</ul>

<p>The plugins offer syntax highlighting, navigation, searching and semantic
renaming for assembly, GPL, and TI (Extended) BASIC programs.</p>

<p>The major design goals of xdt99 and differentiators to similarly spirited
projects such as the <a href="http://www.mizapf.de/ti99/tiimagetool.html">TI Image Tool</a> or the <a href="http://www.99er.net/win994a.shtml">Winasm99 assembler</a> are</p>

<ul>
<li>a comprehensive and consistent developer experience,</li>
<li>a flexible and powerful command-line interface, and</li>
<li>cross-platform availability.</li>
</ul>

<p>Future developments will focus on further simplifying typical development tasks
such as data conversion and program generation.</p>

<p>xdt99 is released under the GNU GPLv2.  All <a href="https://github.com/endlos99/xdt99">sources</a> are available on
GitHub.  TI developers may also download the latest <a href="https://github.com/endlos99/xdt99/releases">binary release</a> of
xdt99.</p>

<p>The <a href="https://endlos99.github.io/xdt99">xdt99 homepage</a> always hosts the latest version of this document.</p>

<h2>Installation</h2>

<p>Download the latest <a href="https://github.com/endlos99/xdt99/releases">binary release</a> from GitHub (recommended) or clone the
<a href="https://github.com/endlos99/xdt99">xdt99 repository</a>.  Please note that the big download buttons on top of the
xdt99 homepage will include the entire repository; this is probably <em>not</em> what
you want.</p>

<p>You will also need a working copy of <a href="https://www.python.org/downloads/">Python 2.x</a> installed on your computer.
<code>xdt99</code> has been developed using Python 2.7, but other versions should work as
well.  Note, however, that compatibility with Python 3 has been postponed to a
later release for now.</p>

<p>Both cross-assemblers and the disk manager are self-contained Python programs
that may be used independently of each other.  The volume manager and the HFE
manager depends on the disk manager and cannot be used without it.  For
installation, simply place the files <code>xas99.py</code>, <code>xga99.py</code>, <code>xbas99.py</code>,
<code>xdm99.py</code>, <code>xhm99.py</code>, and <code>xvm99.py</code> somewhere in your <code>$PATH</code> or where your
command-line interpreter will find them.  Windows users will find additional
information about installation and how to get started in the
<a href="https://github.com/endlos99/xdt99/blob/master/doc/WINDOWS.md">Windows Tutorial</a>.</p>

<p>The <code>ide/</code> directory contains the editor plugins for GNU Emacs and IntelliJ
IDEA.  Please refer to the <code>EDITORS.md</code> file for further information about
editor support.</p>

<p>The <code>lib/</code> directory contains the Jumpstart cartridge and some supporting
functions that you may use in your TI programs.</p>

<p>The <code>example/</code> directory of the binary distribution contains some sample files
that are referenced throughout this manual.</p>

<h2>xas99 Cross-Assembler</h2>

<p>The <code>xas99</code> cross-assembler translates TMS9900 assembly code into executable
programs for the TI 99 home computer equipped with the Editor/Assembler module
or the Mini Memory module.</p>

<p>Invoking <code>xas99</code> in standard mode will assemble a TMS9900 assembly source code
file into an object code file that may be loaded using the Editor/Assembler
module option 3.</p>

<pre><code>$ xas99.py -R ashello.a99
</code></pre>

<p><code>xas99</code> also generates program image files for the Editor/Assembler module
option 5 or RPK cartridge files suitable for the MESS emulator:</p>

<pre><code>$ xas99.py -R -i ashello.a99
$ xas99.py -R -c ashello.a99
</code></pre>

<p>All existing assembly code for the TI 99, e.g., the Tombstone City source code
shipped with the Editor/Assembler module, should cross-assemble using <code>xas99</code>
without requiring any source code modifications.</p>

<p>The object code generated by <code>xas99</code> is identical to uncompressed object code
produced by the original TI Editor/Assembler package.  This includes all of its
quirks, such as shortened object code lines or excessive address specifications,
but hopefully none of its bugs, such as invalid tags for certain <code>DEF</code>s.</p>

<p>For a detailed step-by-step example on how to cross-assemble and run an assembly
program using the xdt99 tools and the MESS emulator please refer to the Example
Usage section below.</p>

<p>Finally, please note that even though the object code format of the TI 99 home
computer shares many similarities with that of other TMS9900-based systems, most
notably the TI 990 mini computers, <code>xas99</code> currently targets the TI 99
exclusively.</p>

<h3>Assembling Source Code</h3>

<p>The <code>xas99</code> cross-assembler reads an assembly source code file and generates an
uncompressed object code file that is suitable for the original TI 99
Editor/Assembler loader.</p>

<pre><code>$ xas99.py -R ashello.a99
$ xas99.py -R ashello.a99 -o HELLO-O
</code></pre>

<p>The output parameter <code>-o</code> may be used to override the default output filename.</p>

<p>The assembly options <code>-R</code> (register symbols), <code>-S</code> (symbol table), <code>-L</code>
(listing), and <code>-C</code> (compressed object code) correspond to the respective
options of the TI Editor/Assembler module.  You will need to add <code>-R</code> if you
prefer to write <code>MOV R0,*R1+</code> etc. instead of <code>MOV 0,*1+</code> in your source code.</p>

<p><code>xas99</code> will report any errors to <code>stderr</code> during assembly.  Note that the
generated object code may differ from the code generated by the Editor/Assembler
package in the case of errors.  <code>xas99</code> is slightly more permissive than the
Editor/Assembler, but it should be able to assemble any source that the
Editor/Assembler package can assemble.</p>

<p>The assembler may also issue a number of <strong>warnings</strong>, as shown in this
example:</p>

<pre><code>val  equ 0
     mov  r0, &gt;000a    ; Treating as register, did you intent an @address?
     ci   r1, r2       ; Register used as immediate operand
     b    @lab         ; Possible B/JMP optimization
     data 0
lab  mov  @val(r1)     ; Using indexed address @0, could use *r1 instead
cons data 1            ; Unreferenced symbol (summary at end of assembly)
</code></pre>

<p>Warnings are also written to <code>stderr</code>.  Option <code>-w</code> disables all warnings.</p>

<h3>Creating Program Images</h3>

<p>The image parameter <code>-i</code> tells <code>xas99</code> to generate image files that can be
loaded using Editor/Assembler option 5.</p>

<pre><code>$ xas99.py -R -i ashello.a99
</code></pre>

<p>Images larger than 8 KB are split automatically into multiple files, using the
filename convention of the Editor/Assembler module.</p>

<p>The <code>-i</code> parameter simulates the <code>SAVE</code> utility program shipped with the
Editor/Assembler package and honors the symbols <code>SFIRST</code> and <code>SLAST</code> to generate
a single image for the entire memory area spanned by those two addresses.  The
image is automatically chunked into 8 KB files for the E/A loader.</p>

<p>Alternatively, if either symbol is missing, <code>xas99</code> will generate separate image
files for each program segment defined in the assembly source code.  For
example, the assembly of source file</p>

<pre><code>     AORG &gt;A000
L1   B @L2
     AORG &gt;B000
L2   B @L1
</code></pre>

<p>will yield two images files of 10 bytes each instead of a single file of 4 KB.</p>

<p>Note that the E/A loader for program files happily loads non-contiguous image
files for individual program segments even though original <code>SAVE</code> utility does
not support this feature.</p>

<p>For further control about the memory regions to save see the <code>SAVE</code> directive
below.</p>

<p>The optional <code>--base</code> argument can be used to define the base address for
relocatable code.  If no base address is given, default address <code>&gt;A000</code> is used.</p>

<p>All the usual restrictions for program images apply.  In particular, the first
word of the first image file must be an executable instruction.</p>

<h3>Creating MESS Cartridges</h3>

<p>The cartridge parameter <code>-c</code> tells <code>xas99</code> to create an RPK cartridge file that
can be used with the MESS emulator.</p>

<pre><code>$ xas99.py -c -R ascart.a99 -n "HELLO WORLD"
</code></pre>

<p>The optional name parameter <code>-n</code> overrides the default name of the program that
shows up in the TI 99 menu selection screen.</p>

<p>The resulting RPK archive is a ZIP file containing the actual program code plus
various information for the MESS emulator on how to execute the program.
Typically, RPK files are passed as arguments to the MESS executable, or they may
be mounted while running MESS using the emulator on-screen menu.</p>

<pre><code>$ mess64 ti99_4ae -cart ascart.rpk
</code></pre>

<p>When the <code>-c</code> option is given, <code>xas99</code> will automatically generate suitable GPL
header information and relocate the program to address <code>&gt;6030</code>, but it will not
process the source code any further.  In particular, the usual restrictions on
using VDP memory access routines apply.</p>

<p>Note that cartridge files cannot be generated from split image files.</p>

<h3>Creating Raw Binaries</h3>

<p>Image files for the E/A loader option 5 contain the actual program code that is
loaded verbatim into memory.  They also contain a small amount of metadata that
instructs the loader how many files to load and where to store the data.</p>

<p>The binary parameter <code>-b</code> tells <code>xas99</code> to generate raw binary files without
metadata that are suitable for burning EPROMs or supplying other devices.</p>

<pre><code>$ xas99.py -b -R ascart.a99 --base 0x6000
</code></pre>

<p>The assembler will generate one binary file per code segment.  For further
control, the <code>SAVE</code> directive may be used (see below).</p>

<p>The optional <code>--base</code> argument sets the base address for relocatable segments;
if no argument is given, <code>&gt;0000</code> is used.</p>

<h3>Creating Text Files</h3>

<p>The text parameter <code>-t</code> generates a textual version of the raw binary generated
by <code>-b</code>.  Followed by <code>a</code>, it creates <code>BYTE</code> or <code>DATA</code> instructions to use in
assembly or GPL; by <code>b</code>, it creates <code>DATA</code> instructions to use in BASIC; by
<code>c</code>, it creates a list of hex values to use in C/C++ arrays.  Including <code>2</code> or
<code>4</code> in the value generates bytes or words, respectively.  For target platforms
with different endianness, include <code>r</code> to swap the bytes in words.  As an
example,</p>

<pre><code>$ xas99.py -t a2 -R example.a99
</code></pre>

<p>results in an assembly file with <code>AORG</code>s and <code>BYTE</code> directives:</p>

<pre><code>;  aorg &gt;1000
   byte &gt;04, &gt;c0, &gt;c0, &gt;81, &gt;04, &gt;60, &gt;20, &gt;00
;  aorg &gt;2000
   byte &gt;02, &gt;e0, &gt;83, &gt;e0, &gt;04, &gt;d0
</code></pre>

<p>The result can be <code>COPY</code>ed, <code>#include</code>d, or just copy-and-pasted.</p>

<h3>Jumpstarting</h3>

<p>To make the code, assemble, run cycle as fast as possible, <code>xas99</code> can
generate so-called "jumpstart disks" that may be loaded and executed by the
Jumpstart cartridge included with xdt99.</p>

<pre><code>$ xas99.py --jumpstart -R ascart.asm
$ mess64 ti99_4ae -cart lib/jumpstart.rpk -flop1 ascart.dsk
</code></pre>

<p>The example above shows the invocation for MESS, but any emulator should
work.  Obviously, the emulator must be setup with 32K memory expansion and
at least one floppy disk drive.</p>

<p>Selecting the Jumpstart option in the TI 99 main menu will load the jumpstarted
program from any inserted disk and run it.  Thus, selecting either option 3
or 5 in the Editor/Assembler module and manually entering the program filename
is no longer required.</p>

<p>Currently, jumpstarted programs may consist of up to 8 segments and must fit
entirely into memory areas <code>&gt;2000</code>-<code>&gt;3EFF</code> and <code>&gt;A000</code>-<code>&gt;FFFF</code>.</p>

<h3>Other Formats</h3>

<p>For relocatable code not larger than around 24 KB, <code>xas99</code> can generate an
Extended BASIC program that invisibly contains the generated code within:</p>

<pre><code>$ xas99.py --embed-xb ashello.a99
</code></pre>

<p>The resulting program is a regular Extended BASIC program in so-called "long"
format that will execute the assembly code when run:</p>

<pre><code>&gt;OLD DSK1.ASHELLO
&gt;RUN
</code></pre>

<p>Thus, the <code>--embed-xb</code> options allows for the creation of assembly programs that
do require the Editor/Assembler module for execution.</p>

<p>The generated Extended BASIC program will have only one visible line:</p>

<pre><code>1 CALL INIT :: CALL LOAD(163
76,88,89,90,90,89,32,255,228
):: CALL LOAD(8196,63,248)::
 CALL LINK("XYZZY")
</code></pre>

<p>But be careful: editing the generated program is likely to corrupt the embedded
assembly code!</p>

<h3>Creating List Files</h3>

<p>The <code>-L</code> option instructs <code>xas99</code> to generate a list file for the assembled
source code:</p>

<pre><code>$ xas99.py -R ashello.a99 -L ashello.lst
</code></pre>

<p>The list file is useful for inferring the relative or absolute memory addresses
of source code lines or the effective values of expressions.</p>

<p>The format of the list file is almost identical to that of the original
Editor/Assembler module.  The most prominent difference is the listing of
the <code>BYTE</code> directive, where individual byte values are grouped into words.</p>

<h3>TMS9900 Assembly Support</h3>

<p>The <code>xas99</code> is a complete TMS9900 assembler supporting all documented TMS9900
opcodes.  TMS9995 opcodes such as <code>MPYS</code> and <code>DIVS</code> are currently not supported
but may be added in a future release.</p>

<p><code>xas99</code> understands all assembler directives described in the Editor/Assembler
manual that are supported by both TI 99 assembler and loader, i.e.,</p>

<pre><code>DEF REF EQU DATA BYTE TEXT BSS BES AORG RORG DORG EVEN
IDT DXOP COPY END
</code></pre>

<p>Note that the <code>DORG</code> directive <em>is</em> supported, even though the TI assembler does
not do so.</p>

<p>The following directives are not supported by the TI 99 loader and are thus
silently ignored by <code>xas99</code>:</p>

<pre><code>PSEG PEND CSEG CEND DSEG DEND LOAD SREF LIST UNL PAGE TITL
</code></pre>

<h4>Source Code Organization</h4>

<p>The <code>COPY</code> directive is used to break large assembly sources into individual
files.</p>

<p><code>xas99</code> will search the current source directory for appropriately named source
files.  For example, assembling</p>

<pre><code>$ xas99.py src/file1.a99
</code></pre>

<p>where <code>file1.a99</code> contains the instruction <code>COPY "DSK1.FILE2"</code> will search for
include files</p>

<pre><code>src/FILE2
src/FILE2.A99
src/FILE2.ASM
src/FILE2.S
</code></pre>

<p>and its corresponding lower-case variants.</p>

<p>Additional search paths may be specified with the <code>-I</code> option as a
comma-separated list, e.g.,</p>

<pre><code>$ xas99.by -I lib/,disk2/ ashello.asm
</code></pre>

<p><code>COPY</code> also supports native file paths, e.g., <code>COPY "ti/src/file2.a99"</code>.</p>

<p><code>xas99</code> also provides a new directive <code>BCOPY</code> that includes an external binary
file as a sequence of <code>BYTE</code>s.  Please refer to the section about <em>xdt99
Extensions</em> for further information.</p>

<h3><code>xdt99</code> Extensions</h3>

<p>The <code>xas99</code> cross-assembler offers various "modern" extensions to the original
TI Assembler to improve the developer experience for writing assembly programs.
All extensions are backwards compatible in virtually all situations of
practical relevance so that any existing source code should compile as-is.</p>

<p><strong>Comments</strong> may be included anywhere in the source code by prepending them
with a semicolon <code>;</code>.  A <code>;</code> character inside a text literal <code>'...'</code> or
filename <code>"..."</code> does <em>not</em> introduce a comment.</p>

<p>Source code is processed case insensitively so that all labels, expressions, and
instructions may be written in upper case, lower case, or any mixture.  Text
literals are still case sensitive, though.</p>

<pre><code>label1 byte &gt;A,&gt;b
LABEL2 TEXT 'Hello World'
Label3 mov Label1(R1),Label2(r2)
</code></pre>

<p><strong>Labels</strong> may be of arbitrary length and may contain arbitrary characters
except for whitespace and operators such as <code>+</code>, <code>*</code>, <code>(</code>, <code>$</code>, etc.  An
optional colon <code>:</code> may be appended to the label name.  The colon is not part
of the name, but logically continues the current line to the next:</p>

<pre><code>my_label_1:
    equ 1         ; assigns 1 to my_label_1
my_label_2:
    aorg &gt;a000    ; assigns &gt;a000 to my_label_2
my_label_3        ; assigns &gt;a000 to my_label_3  \  standard E/A
    aorg &gt;b000    ; no label to assign &gt;b000 to  /  behavior
</code></pre>

<p><strong>Local labels</strong> simplify the implementation of small loops.  A local label is
introduced by an exclamation mark <code>!</code> and an optional name.  Thus, the simplest
local label is just a single <code>!</code>.  Local labels need not be unique within the
program.</p>

<p>References to local labels are resolved relative to the current position.  By
default, matching labels are searched after the current position.  References
prefixed with a unary minus sign <code>-</code> are searched before the current position.</p>

<pre><code>clear_data:
    li   r0, &gt;a000
    li   r2, &gt;100
!   clr  *r0+         ; make jump target without potential name conflicts
    dec  r2
    jne  -!           ; jump to target two lines above
    rt
</code></pre>

<p>Doubling, tripling, ... the number of <code>!</code>s before a reference refers to the
second, third, ... match of the local label relative to the current position:</p>

<pre><code>!   dec  r1              &lt;-+
    jeq  !     --+         |
    inc  r2      |         |
    jne  !!      |  --+    |
    jmp  -!      |    |  --|
!   dec  r2    &lt;-+    |    |
    jmp  -!!          |  --|
!   inc  r1         &lt;-+    |
    jmp  -!!!            --+
!   rt
</code></pre>

<p>Note that labels <code>label</code> and <code>!label</code> are entirely different and can be used
without conflict in the same program.</p>

<p>The use of <strong>whitespace</strong> has been relaxed.  Single spaces may be used
judiciously within the operand field to increase the legibility of expressions.
Two or more spaces as well as tabs introduce the comment field.</p>

<pre><code>label  data addr + len - 1  comment
       movb @addr + 2(r1), *r2+ ; comment
</code></pre>

<p>(<em>Technical note</em>: It is not possible to detect the beginning of the comment
field based on the current instruction, as the example <code>LABEL EQU 1 * 2</code> shows.
The original TI Assembler parses <code>* 2</code> as comment, even though <code>1 * 2</code> is a
valid <code>EQU</code> expression.)</p>

<p>The <strong>extended expression</strong> syntax supports parentheses <code>(</code>, <code>)</code>, the modulo
operator <code>%</code>, and binary operators bit-and <code>&amp;</code>, bit-or <code>|</code>, bit-xor <code>^</code>, and
bit-not <code>~</code> as well as binary literals introduced by <code>:</code>.</p>

<pre><code>area    equ (xmax + 1) * (ymax + 1)
addr2   equ addr1 | &gt;A000 &amp; ~&gt;001F
padding bss size % 8
binval  equ :01011010
</code></pre>

<p>It is important to note that all operators have the <em>same precedence</em>, i.e., an
expression such as <code>1 + 2 * 3 - 4 &amp; 5</code> evaluates as <code>(((1 + 2) * 3) - 4) &amp; 5</code>.
This may sound annoying, but changing the established order of evaluation would
break the compatibility of <code>xas99</code> for existing sources.  To adjust the order of
evaluation, parentheses can be used: <code>1 + (2 * 3) - (4 &amp; 5)</code>.</p>

<p><code>xas99</code> features a number of so-called <strong>modifiers</strong> that apply to symbols,
literals, or registers.</p>

<p>Many programs use byte or word constants, e.g., for <code>MOV</code>/<code>MOVB</code> or <code>C</code>/<code>CB</code>
instructions when immediate values are not available or feasible.  A common
problem then is to keep track of all used constants.  <code>xas99</code> assists the
developer here by warning about unused constants (see Warnings).</p>

<p>A convenient alternative is to use <strong>auto-generated constants</strong> with modifiers
<code>b#</code> and <code>w#</code>.  As an example,  </p>

<pre><code>    mov  w#&gt;ff01, @status
    socb b#81, r1
    cb   @keycode, b#Q
</code></pre>

<p>is equivalent to this code without modifiers:</p>

<pre><code>    mov  @h_ff01, @status
    socb b_81, r1
    cb   @keycode, @b_81
h_ff01:
    data &gt;ff01
b_81:
    byte 81   ; note that 'Q' == 81
</code></pre>

<p>For a word character constant such as 'w#A', a zero byte is appended to the
generated byte, e.g., <code>&gt;4100</code>.</p>

<p>The assembler ensures that each value is added only once, so for constants
<code>b#&gt;41</code>, <code>b#65</code>, and <code>b#A</code>, it will add only one byte to the code.</p>

<p>Please note that the constants must be literals, i.e., constructs like</p>

<pre><code>msk equ &gt;5555
    xor w#msk, r0
</code></pre>

<p>are not valid.  For these case, use regular named constants instead.</p>

<p>The assembler logically appends all auto-generated constants to the end of the
<em>source</em> code.  So if we need to place some data after the code</p>

<pre><code>    save &gt;2000-&gt;2fff

    aorg &gt;2000
start:
    movb b#1, @acc
    ...

    aorg &gt;2ffc
start_vector:
    data &gt;8300
    data start
</code></pre>

<p>using auto-generated constants, we simply reverse the order of our sections</p>

<pre><code>    save &gt;2000-&gt;2fff
    aorg &gt;2ffc
    ...

    aorg &gt;2000
    ...
    ; auto-generated constants follow
</code></pre>

<p>so that the constants are appended to the <code>&gt;2000</code> chunk now.        </p>

<p>All auto-generated constants will also appear in the list file.</p>

<p>The new <strong>register LSB</strong> modifier <code>l#</code> represents the address of the LSB of the
modified register.  In this code example,</p>

<pre><code>    lwpi &gt;8300
    ...
    movb l#r0, @vdpwa
    movb r0, @vdpwa
</code></pre>

<p>the expression <code>l#r0</code> resolved to <code>@&gt;8301</code>, i.e., the LSB of register 0.  The
modifier is relative to the workspace pointer (WP) so that</p>

<pre><code>    lwpi &gt;8300
    movb l#r1, r0
    lwpi &gt;2000
    movb l#r1, r0
    lwpi &gt;83e0
    movb l#r1, r0
</code></pre>

<p>reads <code>&gt;8303</code>, <code>&gt;2003</code>, and <code>&gt;83E3</code>, respectively.</p>

<p><em>Caution!</em> <code>l#</code> uses the syntactically most recent <code>LWPI</code> statement.  When
using multiple workspaces or inside <code>BLWP</code> subroutines, make sure that the
workspace is still set correctly, or don't use 'l#' at all.</p>

<p>Finally, the <strong>symbol size</strong> modifier <code>s#</code> returns the size of the label it is
attached to.  Size here means the number of bytes from this symbol to the
subsequent symbol in the source code.</p>

<pre><code>     li   r0, 320
     li   r1, text1
     li   r2, s#text1   ; s#text1 == 12
     bl   @vmbw
     ...
text1:
    text 'HELLO WORLD!'
text2:
    text 'GOOD BYE!'
</code></pre>

<p>In this example, <code>s#text1</code> equals 12, since there are 12 bytes from <code>text1</code> to
<code>text2</code>.</p>

<p>The size modifier detects if the last byte of the range is a padding byte and
subtracts it from the size.</p>

<pre><code>text1:
    text 'HELLO WORLD'
text2:
    text 'GOOD BYE!'
</code></pre>

<p>Here, <code>s#text1</code> equals 11, even though there are still 12 bytes from <code>text1</code> to
<code>text2</code>.  Please note that <code>s#</code> only applies to labels; symbols created by
<code>EQU</code>s are not supported.</p>

<p>The <strong>cross-bank access</strong> modifier <code>x#</code> enables cross-bank symbol access.  For
a detailed description on <code>x#</code>, see the paragraphs on bank switching.</p>

<p><code>xas99</code> also provides <strong>new directives</strong>.  The <code>BCOPY</code> directive includes an
external binary file as a sequence of <code>BYTE</code>s.  For example, if <code>sprite.raw</code>
is a raw data file containing some sprite pattern</p>

<pre><code>$ hexdump -C sprite.raw
00000000  18 3c 7e ff ff 7e 3c 18                           |.&lt;~..~&lt;.|
</code></pre>

<p>then including this file with <code>BCOPY</code></p>

<pre><code>SPRITE  BCOPY "sprite.raw"
</code></pre>

<p>is equivalent to the conventional assembly statement sequence</p>

<pre><code>SPRITE  BYTE &gt;18,&gt;3C,&gt;7E,&gt;FF,&gt;FF,&gt;7E,&gt;3C,&gt;18
</code></pre>

<p>The <code>STRI</code> directive is similar to <code>TEXT</code>, but prepends the length of the
string.  In other words,</p>

<pre><code>STRI 'HELLO WORLD'
</code></pre>

<p>is equivalent to</p>

<pre><code>TEXT &gt;0b, 'HELLO WORLD'
</code></pre>

<p>The <code>FLOA</code> directive stores a decimal number in the 8-byte RADIX-100 format
used by the TI 99.  Note that digits exceeding the accuracy of RADIX-100 are
silently ignored.</p>

<pre><code>FLOA 123.456789012
</code></pre>

<p>The exponent notation <code>1e9</code> is currently not supported.</p>

<p>The <code>BANK</code> directive specifies the memory bank for the following code segment,
or a shared code segment if the special value <code>ALL</code> is used.  Banks count from
zero.</p>

<pre><code>* ASBANK.A99
      AORG &gt;6000
      BANK ALL
FUNC1 CLR R0
      ...
      BANK 1
FUNC2 LI  R1,&gt;1234
      ...
</code></pre>

<p>Note that the optional second argument of the <code>AORG</code> directive to specify the
current bank is now deprecated, and might be removed in a future version of
<code>xas99</code>.</p>

<p>Generating binary files with the <code>-b</code> command stores banked segments in
separate files, e.g.,</p>

<pre><code>$ xas99.py -b asbank.a99
$ ls
asbank.a99  asbank_6000_b0.bin  asbank_6000_b1.bin
</code></pre>

<p><code>xas99</code> warns about illegal cross-bank accesses in address arguments, but
access from and to shared code segments are not checked.</p>

<pre><code>      AORG &gt;6000
      BANK 0
L1    B    @L3      ; OK
      B    @L2      ; error: different bank

      BANK 1
L2    B    @L3      ; OK
      B    @L1      ; error: different bank

      AORG &gt;7000
      BANK ALL
L3    B    @L1      ; OK, implies correct bank is present
      B    @L2      ; OK, implies correct bank is present
</code></pre>

<p>In this example, the <code>B</code> instructions in segment <code>&gt;7000</code> will branch to <code>L1</code>
or <code>L2</code>, depending on which bank is active.</p>

<p>To override the cross-bank check explicitly, e.g., because the caller will be
relocated to a different memory address during runtime, the <strong>cross-bank
modifier</strong> <code>x#</code> can be prepended to the offending label.</p>

<pre><code>      BANK 0
CONT  CLR  R0

      BANK 1
      B    @X#CONT  ; OK, no error
</code></pre>

<p>The new <code>XORG</code> directive sets the location counter to a new address but does
not change the actual placement of the subsequent code segment.</p>

<pre><code>      AORG &gt;6000
L1    DATA 0
      MOV  @L1,@L2      ; moves &gt;6000 to &gt;8380
      BL   @FUNC        ; branches to &gt;8382

A1    XORG &gt;8380
A2
L2    DATA 0
FUNC  A    @L2,@L1      ; adds &gt;8380 to &gt;6000
      RT
A3
</code></pre>

<p>The list file for this program shows that the code of <code>FUNC</code> is placed within
the <code>&gt;6000</code> segment:</p>

<pre><code>0001                      AORG &gt;6000
0002 6000 0000     L1     DATA 0
0003 6002 C820  54        MOV  @L1,@L2      ; moves &gt;6000 to &gt;8380
     6004 6000
     6006 8380
0004 6008 06A0  32        BL   @FUNC        ; branches to &gt;8382
     600A 8382
0005
0006               A1     XORG &gt;8380
0007               A2
0008 600C 0000     L2     DATA 0
0009 600E A820  54 FUNC   A    @L2,@L1      ; adds &gt;8380 to &gt;6000
     6010 8380
     6012 6000
0010 6014 045B  20        RT
0011               A3
</code></pre>

<p><code>XORG</code> is useful for assembling code blocks that will be moved to a different
memory location, e.g., scratch pad RAM, before execution.</p>

<pre><code>* MOVE FUNCTION TO SCRATCH PAD RAM
INIT  LI   R0,A1        ; source address of function
      LI   R1,A2        ; target address of function
      LI   R2,A3-A2     ; length of function to copy
      BL   @COPY        ; fictious RAM to RAM copy routine
</code></pre>

<p>Note that <code>xas99</code> cannot place <code>XORG</code> code directly into the indented target
location; instead, all such blocks need to be copied manually in your program.
For this, <code>XORG</code> assigns the real placement address instead of the location
counter to its label.  Depending on the previous segment this address may be
relocatable or not.</p>

<p>The <code>XORG</code> directive can be used for all <code>xas99</code> output formats and is
compatible with both E/A option 3 and E/A option 5.</p>

<p>The <code>SAVE</code> directive controls the output format for the image <code>-i</code> and raw
binary <code>-b</code> output formats.</p>

<pre><code>      SAVE &gt;6000,&gt;7000   ; generate single image for &gt;6000-&gt;6FFF

      AORG &gt;6000
MAIN  LIMI 0
      ...
      AORG &gt;6100
SUBR  CLR  R0
      ...
</code></pre>

<p>For each <code>SAVE</code>, a binary file containing the values of the specified memory
region will be generated.  If the region contains banked memory, a separate file
for each bank is written.  Empty regions, i.e., regions in which no actual value
is placed, are skipped.</p>

<p>If no <code>SAVE</code> directives are provided, the <code>-b</code> command will place each segment
in its own output file, but merges adjacent segments into one file.  The <code>-i</code>
command will save the region between symbols <code>SFIRST</code> and <code>SLAST</code>, if present;
otherwise, it generates images for each segment individually.</p>

<p>The use of <code>SAVE</code> is recommended to reduce the number of generated files if
<code>XORG</code> is employed.</p>

<p>The source code <strong>preprocessor</strong> allows for conditional assembly based on
well-defined conditional expressions.  The preprocessor commands <code>.ifdef</code> and
<code>.ifndef</code> check if a given symbol is defined or not.</p>

<pre><code>       .ifdef lang_de
msg    text 'Hallo Welt'
       .else
msg    text 'Hello World'
       .endif
</code></pre>

<p>The commands <code>.ifeq</code>, <code>.ifne</code>, <code>.ifgt</code>, and <code>.ifge</code> test if two arguments are
equal, not equal, greater than, or greater than or equal, resp.  If the second
argument is missing, the first argument is compared against value <code>0</code>.</p>

<p>Conditional assembly preprocessor commands may be nested.  Valid conditional
expressions and their rules of evaluation correspond to those of the <code>EQU</code>
directive.</p>

<p>The <code>.print</code> preprocessor command prints its arguments to <code>stdout</code>.</p>

<pre><code>val    equ 42
       .print 'Selected answer is', value
</code></pre>

<p>The <code>.error</code> command prints a message and aborts the assembly.</p>

<pre><code>       aorg &gt;6000

       ...

       .ifgt $, &gt;7fff
       .error 'Catridge program too large'
       .endif
</code></pre>

<p>In addition to symbols defined by labels, <code>xas99</code> also sets exactly one of
<code>_xas99_image</code>, <code>_xas99_cart</code>, <code>_xas99_obj</code>, <code>_xas99_xb</code>, or <code>_xas99_js</code>,
depending on the assembly command <code>-i</code>, <code>-c</code>, ... used.</p>

<p><strong>Additional symbols</strong> may be supplied on the command line.</p>

<pre><code>$ xas99.py ashello.a99 -D symbol1 symbol2=2
</code></pre>

<p>If no value is given, the symbol is set to value <code>1</code>.</p>

<p>The symbol option <code>-E</code> dumps all symbols in EQU-like syntax to an external
file <code>sym.a99</code>:</p>

<pre><code>$ xas99.py ashello.a99 -E sym.a99
</code></pre>

<p>which then reads:</p>

<pre><code>CLS:
       equ  &gt;002E  ; REL    &lt;-- was relocatable address
GPLST:
       equ  &gt;837C  ;
KCODE:
       equ  &gt;8375  ;
KEYSC:
       equ  &gt;005C  ; REL
...
</code></pre>

<p><code>xas99</code> supports <strong>macros</strong>.  The <code>.defm</code> preprocessor command introduces a new
macro.  The <code>.endm</code> command concludes the macro definition.  Inside the macro
body the macro parameters <code>#1</code>, <code>#2</code>, ... refer to the actual arguments that
are supplied when instantiating the macro:</p>

<pre><code>* fill top &lt;#1&gt; rows with char &lt;#2&gt;
    .defm fill
    li   r0, &gt;0040
    li   r1, #1
    li   r2, #2 * 32
    movb @vdpwa
    swpb r0
    movb @vdpwa
!   movb r1, @vdpwd
    dec  r2
    jne  -!
    .endm
</code></pre>

<p>Macros are used like preprocessor commands, with any arguments separated
by commas:</p>

<pre><code>    .fill 10, '* '
</code></pre>

<p>Note that macro parameters are resolved by textual replacement.  Thus,
when instantiating</p>

<pre><code>    li   r0, 2 * #1
</code></pre>

<p>inside some macro body with argument <code>1 + 2</code>, the resulting code will assign
the value 4 instead of 6 to <code>R0</code>.</p>

<p>Labels are allowed inside macro definitions.  To avoid duplicate symbols, all
labels should be local.</p>

<p>Macro definitions cannot be nested.  Macro uses may be nested, but
instantiations must not be circular.</p>

<p>Preprocessor commands are always executed, even inside inactive <code>#ifdef</code> ...
<code>#endif</code> blocks.  The correct way to define environment-dependent macros is
thus</p>

<pre><code>.defm mymacro
.ifdef symbol
clr r0
.else
clr r1
.endif
.endm
</code></pre>

<p>instead of the other way around.</p>

<p><code>xas99</code> supports the <strong>F18A GPU instruction set</strong>.</p>

<pre><code>CALL &lt;gas&gt;
RET
PUSH &lt;gas&gt;
POP  &lt;gad&gt;
SLC  &lt;wa&gt;, &lt;count&gt;
PIC  &lt;gas&gt;, &lt;gad&gt;
</code></pre>

<p>Note that <code>PIC</code> is not an immediate instruction, so its arguments need to be
constructed separately by hand.</p>

<p>The <code>SPI</code> family of instructions is not supported; please use their equivalents
<code>CKON</code>, ... instead.</p>

<h3>Compatibility</h3>

<p>The strictness option <code>-s</code> disables all <code>xas99</code>-specific extensions to improve
backwards compatibility for old sources:</p>

<pre><code>$ xas99.py -s ashello.a99
</code></pre>

<p>Strictness is required, for example, to compile the <em>Tombstone City</em> sample
source code shipped with the original TI Editor/Assembler module.  Some of the
comments do not adhere to the two-space separator rule of the relaxed xdt99
whitespace mode:</p>

<pre><code>R5LB   EQU SUBWS+11 * REGISTER 5 LOW BYTE.
***** Unknown symbol: REGISTER 5 LOW BYTE.
</code></pre>

<p>Finally, note that case insensitivity cannot be disabled at the moment.</p>

<h2>xga99 GPL Cross-Assembler</h2>

<p>The <code>xga99</code> GPL cross-assembler translates programs written in TI's proprietary
Graphics Programming Language into byte code that can be interpreted by the TI
99 home computer.</p>

<p>Invoking <code>xga99</code> in standard mode will assemble a GPL source code file into
plain GPL byte code that may be placed in a physical or emulated GROM or GRAM
device.</p>

<pre><code>$ xga99.py gahello.gpl
$ xga99.py gahello.gpl -o gahello.bin
</code></pre>

<p>The output parameter <code>-o</code> may be used to override the default output filename,
which uses extension <code>.gbc</code> (for "GPL byte code").</p>

<p>The image parameter <code>-i</code> tells <code>xga99</code> to generate suitable GPL header data for
the program so that the GPL byte code interpreter built into the TI 99 can
execute the image file.</p>

<pre><code>$ xga99.py -i gahello.gpl
</code></pre>

<p><code>xga99</code> will check if there is enough space at the beginning of the image file
for inserting GPL header data.  You may have to adjust (or remove) any <code>AORG</code>
directives if there is not enough space available.</p>

<p>Program execution will start at the symbol provided with the <code>END</code> directive, or
the <code>START</code> symbol, or the first byte of the byte code, in this order.</p>

<p>The cartridge parameter <code>-c</code> relocates the GPL program to the cartridge GROM
area, generates GPL header data, and packages the byte code image into a
cartridge file suitable for the MESS emulator.</p>

<pre><code>$ xga99.py -c gahello.gpl
</code></pre>

<p>The resulting <code>.rpk</code> file may be executed as-is by the MESS emulator:</p>

<pre><code>$ mess64 ti99_4ae -cart gahello.rpk
</code></pre>

<p>The optional name parameter <code>-n</code> overrides the default name of the program that
shows up in the TI 99 menu selection screen.</p>

<pre><code>$ xga99.py -c gahello.gpl -n "HELLO GPL WORLD"
</code></pre>

<p>The optional list file parameter <code>-L</code> creates a list file of the source that
shows the addresses and their byte values for each source line.</p>

<pre><code>$ xga99.py gahello.gpl -L gahello.lst
</code></pre>

<p>When <code>-L</code> is given, the symbol dump parameter <code>-S</code> includes the symbol table in
the list file.</p>

<p>As the Graphics Programming Language was never intended for public release,
existing native tools for assembling GPL source code differ substantially in
the language syntax they support.  <code>xga99</code> adopts a combination of the Ryte
Data GPL Assembler and the RAG GPL Assembler syntax as its native format.
Other syntax styles may be chosen with the syntax parameter <code>-y</code>.</p>

<pre><code>$ xga99.py sdemo.gpl -y mizapf
</code></pre>

<p>Currently supported syntax styles are the default <code>xdt99</code> for the <code>xga99</code>
native format, and <code>mizapf</code> for the TI Image Tool GPL disassembler.  Note that
the original GPL syntax described in TI's <em>GPL Programmer's Guide</em> was
considered too arcane for inclusion in <code>xga99</code>.</p>

<p>The native <code>xdt99</code> syntax style is more "modern" in that it supports lower case
sources and relaxes the use of whitespace.  For details, please refer to the
respective section of the <code>xas99</code> manual.</p>

<h3>GPL Instructions</h3>

<p><code>xga99</code> supports all GPL mnemonics described in the <em>GPL Programmer's Guide</em>.
As is common practice, however, the operand order for the shift instructions
<code>SLL</code> etc. has been reversed from <code>Gd, Gs</code> to <code>Gs, Gd</code>.</p>

<p>Instruction operands use the well-established prefix notation to address CPU
RAM, VDP RAM, and GROM/GRAM, respectively:</p>

<pre><code>@&lt;cpuram addr&gt;  ....................  CPU RAM direct
*&lt;cpuram addr&gt;  ....................  CPU RAM indirect
V@&lt;vdpram addr&gt;  ...................  VDP RAM direct
V*&lt;cpuram addr&gt;  ...................  VDP RAM indirect
@&lt;cpuram addr&gt;(@&lt;cpuram addr&gt;)  ....  CPU RAM indexed
V@&lt;vdpram addr&gt;(@&lt;cpuram addr&gt;)  ...  VDP RAM indexed
G@&lt;grom addr&gt;  .....................  GROM/GRAM direct   (MOVE only)
G@&lt;grom addr&gt;(@&lt;cpuram addr&gt;)  .....  GROM/GRAM indexed  (MOVE only)
#&lt;vdp reg&gt;  ........................  VDP register       (MOVE only)
</code></pre>

<p>Note that symbols do not imply a certain memory type, so references to GROM
addresses in <code>MOVE</code> instructions still need to prepend <code>G@</code> to the symbol name:</p>

<pre><code>t1 text 'HELLO'
l1 move 5,g@t1,v@100
</code></pre>

<p>For branch and call instructions, prefixing addresses by <code>G@</code> is optional, as
branch targets always reside in GROM/GRAM:</p>

<pre><code>b l1
b G@l1
</code></pre>

<p>Instruction operands may be complex expressions of symbols and literals.
Literals may be decimal numbers, hexadecimal numbers prefixed by <code>&gt;</code>, binary
numbers prefixed by <code>:</code>, and text literals enclosed in single quotes <code>'</code>.</p>

<pre><code>byte 10, &gt;10, :10, '1'
</code></pre>

<p><strong>Expressions</strong> are built using arithmetical operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>,
and <code>**</code> and bit operators <code>&amp;</code>, <code>|</code>, <code>^</code>, and <code>~</code>.  Expressions are evaluated
left-to-right with equal operator precedence; parentheses may be used to change
the order of evaluation.  For further details please refer to the <code>xas99</code>
section on expressions.</p>

<p>By default, <code>xga99</code> uses the following mnemonics for the <strong><code>FMT</code> sub-language</strong>,
but other syntax styles are available with the <code>-s</code> option:</p>

<pre><code>HTEXT/VTEXT &lt;text&gt;
HCHAR/VCHAR &lt;count&gt;, &lt;char&gt;
HSTR &lt;count&gt;, &lt;addr&gt;        (no GROM, no VDP, no indexing, no indirection)
ROW/COL &lt;count&gt;
ROW+/COL+ &lt;count&gt;
BIAS &lt;count/gs&gt;
FOR &lt;count&gt; ... FEND [&lt;label&gt;]
</code></pre>

<p>All arguments are immediate values, unless noted.</p>

<p>Note that unlike the Ryte Data GPL Assembler, <code>xga99</code> also supports the optional
address label for the <code>FEND</code> instruction.</p>

<h3>GPL Directives</h3>

<p>The <code>xga99</code> GPL assembler supports the following directives:</p>

<pre><code>GROM AORG EQU DATA BYTE TEXT STRI FLOAT BSS TITLE COPY BCOPY
</code></pre>

<p>Directives affecting listing generation are currently ignored:</p>

<pre><code>PAGE LIST UNL LISTM UNLM
</code></pre>

<p>Most <code>xga99</code> directives work very similar to their <code>xas99</code> counterparts.</p>

<p>The <code>BYTE</code> and <code>DATA</code> directives insert bytes and words into the program,
respectively, irrespective of the size of their arguments.</p>

<pre><code>label byte 1,&gt;02,:11011010,'@',&gt;100
      data 1,&gt;1000,'A'
</code></pre>

<p>The <code>TEXT</code> directive generates a sequence of bytes from a text literal or an
extended hexadecimal literal.</p>

<pre><code>label text 'Groovin'' With GPL'
      text &gt;183C7EFFE7C381
</code></pre>

<p>Note that the second instruction is equivalent to <code>BYTE &gt;18,&gt;3C,&gt;7E,...</code>.</p>

<p>The <code>STRI</code> directive works similar to the <code>TEXT</code> directive but prepends the
a length byte to the generated byte sequence.</p>

<p>The <code>FLOAT</code> directive stores a decimal number in the 8-byte RADIX-100 format
used by the TI 99.  Note that digits exceeding the accuracy of RADIX-100 are
silently ignored.</p>

<pre><code>float -123.456789012
</code></pre>

<p>The exponent notation <code>1e9</code> is currently not supported.</p>

<p>The <code>GROM</code> directive sets the GROM base address for the code that follows.
You can specify either the GROM number <code>0</code>, ..., <code>7</code>, or the absolute address
<code>&gt;0000</code>, ..., <code>&gt;e000</code>, where bits 0-12 are ignored.</p>

<p>If more than one <code>GROM</code> directive is placed in one program, each GROM segment
will be placed in a separate file, whose name is appended with the address of
that segment (similar to <code>xas99</code> with multiple <code>AORG</code> directives).</p>

<p>The <code>AORG</code> directive is used to place individual code segments at specific
addresses <em>within</em> the given GROM.  The address argument is thus relative to
the GROM base address given by <code>GROM</code>.</p>

<p>Instead of using the <code>GROM</code> and <code>AORG</code> directives in the source file the
location of the final GPL byte code image may also be specified by command-line
parameters <code>-G</code> and <code>-A</code>, respectively.  The cartridge parameter <code>-c</code> implies
<code>-G 0x6000</code> and <code>-A 0x30</code>.  <code>-G</code> and <code>-A</code> will not override <code>GROM</code> or <code>AORG</code>
directives, but set the GROM and address of the first line of the code.</p>

<p>The <code>COPY</code> and <code>BCOPY</code> directives include text files or binary files,
respectively.  A text file becomes part of the assembly source, whereas a
binary is included verbatim into the byte code.</p>

<h3><code>xdt99</code> Extensions</h3>

<p>The <code>xga99</code> GPL cross-assembler offers various "modern" extensions to the
original TI GPL specification to improve the developer experience for writing
GPL programs.  All extensions are backwards compatible in virtually all
situations of practical relevance so that any existing source code should
compile as-is.</p>

<p>The <code>xas99</code> extensions regarding <strong>comments</strong>, <strong>labels</strong>, <strong>whitespace</strong>, and
<strong>expressions</strong> also apply to <code>xga99</code>.</p>

<p>The source code <strong>preprocessor</strong> supports conditional assembly <code>.ifdef</code> and
macros <code>.defm</code>.  For a description of both features please refer to the
respective section in the <code>xas99</code> manual.</p>

<p><code>xga99</code> supports <strong>macros</strong>.  Note, however, that GPL macros use macro
parameters <code>$1</code>, <code>$2</code>, ... instead of <code>#1</code>, <code>#2</code>, ..., as the <code>#</code> sign is used
to denote VDP registers in GPL.</p>

<p>The <strong>predefined symbols</strong> set by <code>xga99</code> are <code>_xga99_image</code>, <code>_xga99_cart</code>, or
<code>_xga99_gbc</code>, depending on the assembly command <code>-i</code>, <code>-c</code>, ... used.</p>

<p><strong>Local labels</strong> are non-unique source-relative labels that begin with an
exclamation mark <code>!</code>.  For details about local labels, please refer to the
Local labels section of the <code>xas99</code> cross-assembler manual.</p>

<p>The <strong>command line options</strong> <code>-D</code> to define additional symbols and <code>-E</code> to dump
all symbols in EQU format to an external file work similar to their
counterparts in <code>xas99</code>.</p>

<h2>xda99 Disassembler</h2>

<p>The cross-disassembler <code>xda99</code> is a command-line tool to convert machine code
into assembly source code.</p>

<p>To disassemble a binary machine code file, we need to tell the disassembler the
first address of the machine code with parameter <code>-a</code> and the starting address
for the disassembly with <code>-f</code>:</p>

<pre><code>$ xda99.py ascart_6000.bin -a 6000 -f 600c
</code></pre>

<p>All command line values are interpreted as hexadecimal values.  They can
optionally be prefixed by <code>&gt;</code> or <code>0x</code>.</p>

<p>The strict option <code>-s</code> generates all output files in legacy Editor/Assembler
format.</p>

<p>The resulting file has the same name as the binary file but ends in <code>.dis</code>.  It
contains the disassembled instructions in a list file-like list:</p>

<pre><code>            aorg &gt;6000
6000 4845?
6002 4c4c?
6004 4f20?
6006 4341?
6008 5254?
600a 2100?
600c 0300   limi  &gt;0000
600e 0000
6010 02e0   lwpi  pad
6012 8300
6014 04c0   clr   r0
...
</code></pre>

<p>The output option <code>-o</code> redirects the output to a different file, or prints to
<code>stdout</code> when using the special filename <code>-</code>.</p>

<p>The area to disassemble can be specified with the <em>from</em> parameter <code>-f</code> and the
optional <em>to</em> parameter <code>-t</code>.</p>

<p>The skip option <code>-k</code> skips some prefix of the binary to disassemble.  For
example, when disassembling an E/A option 5 binary, use <code>-k</code> to skip the 6-byte
header:</p>

<pre><code>$ xda99.py program5.bin -k 6 -a a000 -r a000
</code></pre>

<p>Machine code consists of both code and data segments, which are often
intermingled.  Without context information, however, a disassembler cannot tell
data from code.</p>

<p>Using <code>xda99</code> with the <em>from</em> parameter <code>-f</code> will start the disassembly in
<em>top-down mode</em>, which disassembles the machine code sequentially word by word.
As stated above, this mode generally yields bad results, as data segments will
be translated into accurate, but meaningless statements.  This can be seen with
above example by changing the from parameter to <code>-f 6000</code>:</p>

<pre><code>            aorg &gt;6000
6000 4845   szc   r5, @&gt;4c4c(r1)     |
6002 4c4c                            |  data erroneously
6004 4f20   szc   @&gt;4341, *r12+      |  disassembled into
6006 4341                            |  source code
6008 5254   szcb  *r4, r9            |
600a 2100   coc   r0, r4             |
600c 0300   limi  &gt;0000
600e 0000
</code></pre>

<p>Even worse, disassembling data into nonsense statements can spill over to the
real code if the last data word is assembled into a two-word instruction:</p>

<pre><code>    aorg &gt;a000
    byte 4, 224
start:
    lwpi &gt;8300
    limi 0
    ...
</code></pre>

<p>Disassembling the machine code generated by above program with <code>-f a000</code> yields</p>

<pre><code>            aorg &gt;a000
a000 04e0   clr  @&gt;02e0        |  disassembled data
a002 02e0                      |  swallowed the LWPI
a004 8300   c    r0, r12       |  instruction
a006 0300   limi &gt;0000
a008 0000
...
</code></pre>

<p>If the data segments are known, those can be excluded from disassembly with the
exclude <code>-e</code> option:</p>

<pre><code>$ xda99.py ascart_6000.bin -a 6000 -f 6000 -e 6000-600c 70e0-7f00
</code></pre>

<p>The upper address <code>yyyy</code> of an exclude range <code>xxxx-yyyy</code> is not included in the
range, so range <code>6000-6000</code> is an empty range.</p>

<p>For unknown programs, exclusion of data segments is difficult.  Thus, <code>xda99</code>
offers an additional <em>run mode</em> <code>-r</code> that recognizes static branch, call, and
return statements, and disassembles only along the program flow.</p>

<pre><code>$ xda99.py ascart_6000.bin -a 6000 -r 600c
</code></pre>

<p>Note that for the <code>ascart</code> program, there won't be any differences between run
mode and top-down mode, as code and data are separate in that program.</p>

<p>Run mode is not limited to one starting address:</p>

<pre><code>$ xda99.py suprdupC.bin -a 6000 -r 6034 603c
</code></pre>

<p>For convenience, the special address <code>start</code> denotes all start addresses derived
for the given machine code.  Thus, the above line becomes</p>

<pre><code>$ xda99.py suprdupC.bin -a 6000 -r start
</code></pre>

<p>If the binary is not a cartridge image, <code>start</code> will currently default to the
beginning given by <code>-a</code>.</p>

<p>Run mode also includes jump markers as comments that show from where an
instruction was branched to:</p>

<pre><code>6058 d809   movb r9, @&gt;837c
605a 837c
605c d809   movb r9, @&gt;8374           ; &lt;- &gt;6068
605e 8374
6060 0420   blwp @kscan
6062 2108
6064 9220   cb   @&gt;8375, r8
6066 8375
6068 13f9   jeq  &gt;605c
606a d020   movb @&gt;8375, r0
606c 8375
</code></pre>

<p>The program option <code>-p</code> turns the disassembly into actual source code that can
be re-assembled again:</p>

<pre><code>       aorg &gt;6000
vdpwd  equ  &gt;8c00
pad    equ  &gt;8300
gpllnk equ  &gt;2100
vdpwa  equ  &gt;8c02
l6000  data &gt;4845
l6002  data &gt;4c4c
l6004  data &gt;4f20
l6006  data &gt;4341
l6008  data &gt;5254
l600a  data gpllnk
l600c  limi &gt;0000
l600e
l6010  lwpi pad
l6012
l6014  clr  r0
...
</code></pre>

<p>The <code>-p</code> options will also include an <code>EQU</code> stanza of all symbols used, in this
case all <code>xas99</code> internal symbols that were referred (<code>REF</code>) by the program.</p>

<p>To use more symbols, a symbol file can be supplied with the <code>-S</code> parameter.  The
symbol file can be generated with the EQU option <code>-E</code> of <code>xas99</code>, which is
admittedly a rare case in practice, or written manually in fairly free form,
e.g.,</p>

<pre><code>s1 equ &gt;10
s2:
        equ 10
s3 &gt;10
s4: 0x10
</code></pre>

<p>Data segments often contain strings, that can be restored heuristically by using
the string option <code>-n</code>, either with or without the <code>-p</code> option.</p>

<pre><code>            aorg &gt;6000
6000 4845   text  'hello cart'
6002 4c4c
6004 4f20
6006 4341
6008 5254
600a 2100?
600c 0300   limi  &gt;0000
600e 0000
6010 02e0   lwpi  pad
</code></pre>

<p>Option <code>-n</code> is only useful in run mode, as top-down mode will not leave behind
any data segments, where strings could be found.</p>

<p>Note that currently, <code>xda99</code> only disassembles even length strings.</p>

<p>The concise option <code>-c</code> ignores all non-disassembled addresses in the output by
merging those addresses marked by <code>?</code> and replacing them by <code>....</code>.</p>

<pre><code>            aorg &gt;2000
2000 1008   jmp  &gt;2012
....
2012 c481   mov  r1, *r2
2014 05a2   inc  @&gt;0002(r2)
2016 0002
2018 2881   xor  r1, r2
201a 1309   jeq  &gt;202e
201c 10fa   jmp  &gt;2012
</code></pre>

<p>Options <code>-c</code> and <code>-p</code> cannot be combined.</p>

<p>The strict option <code>-s</code> generates output files in legacy Editor/Assembler
format, in particular upper-case.</p>

<p>The register option <code>-R</code> tells the disassembler to use plain integers for
registers, i.e., to <em>not</em> prepend registers with <code>R</code>.</p>

<h3>Run Mode and Conflicts</h3>

<p>When the run mode disassembler hits an address which has already been
disassembled, it stops the current run.  This regularly happens for multiple
calls to a subroutine, loops, or recursion.  The disassembler hitting an address
where it has previously disassembled a statement is perfectly normal and
correct.</p>

<p>But run mode is not always 100% accurate, as <code>xda99</code> cannot follow indirect
branches such as <code>B *R1</code>, and doesn't know if a condition for <code>JEQ LABEL</code> is
always true and thus has no alternate path.  (The latter remark is more
relevant for <code>xdg99</code>, where <code>BR</code> is often used as a shorter <code>B</code>.)  As a
consequence, a run may "run off", and worse, different runs may try to
disassemble the same range differently:</p>

<pre><code>               First run,              Second run,
               starting @&gt;6000         starting @&gt;6002

               aorg &gt;6000              aorg &gt;6000
6000 c820      mov  @pad, @&gt;831c                         |
6002 8300                              c    r0, r12      | disagreement
6004 831c                              c    *r12, r12    |
6006 0a51      sla  r1, 5              sla  r1, 5
6008 1620      jne  &gt;604a              jne  &gt;604a
</code></pre>

<p>Above, the second run hit an address that is only <em>part</em> of a previously
disassembled address (i.e., an operator), which raises a conflict about which
version is correct.</p>

<p>The default behavior of <code>xda99</code> is to stop the run, leaving the previous
disassembly untouched.  You can override the default with the force option
<code>-F</code>, which will always overwrite previous results.  This is done cleanly, so
that run 2 above will reset the overridden instruction at address <code>@&gt;6000</code>.</p>

<p>There is no recommendation to disassemble with or without override.  The result
of each disassembly may vary with each binary, and should be tried out.</p>

<h2>xdg99 GPL Disassembler</h2>

<p>The GPL disassembler <code>xdg99</code> is a command-line tool to convert GPL bytecode
into GPL source code.</p>

<p><code>xdg99</code> shares almost all options with <code>xda99</code>, and works very similar.  In
fact, at some point in the future, both programs might be merged into one.</p>

<p>To show the similarities,</p>

<pre><code>$ xdg99.py gacart.bin -a 6000 -f 6030
</code></pre>

<p>disassembles bytecode file <code>gacart.bin</code>, i.e., a GROM file, into GPL
instructions:</p>

<pre><code>          grom &gt;6000
          aorg &gt;0000
6000 aa?
...
602f 00?
6030 07   all   &gt;20
6031 20
6032 04   back  &gt;04
6033 04
6034 be   st    &gt;48, v@&gt;0021
6035 a0
6036 21
6037 48
...
</code></pre>

<p>The only option that <code>xdg99</code> features over <code>xda99</code> is the syntax selection
option <code>-y</code>, which is already known from <code>xga99</code>:</p>

<pre><code>$ xdg99.py gacart.bin -a 6000 -f 6030
...
6206 31   move &gt;0010, g@&gt;6ec4, v@&gt;0033
...

$ xdg99.py gacart.bin -a 6000 -f 6030 -y mizapf
...
6206 31   move &gt;0010 bytes from grom@&gt;6ec4 to vdp@&gt;0033
...
</code></pre>

<p>At the same time, the <code>-R</code> option of <code>xda99</code> has no meaning for GPL, and thus
is not supported by <code>xdg99</code>.</p>

<h2>xbas99 TI BASIC and TI Extended BASIC Tool</h2>

<p><code>xbas99</code> is a command-line tool for converting TI BASIC and TI Extended BASIC
programs from source format to internal format, and vice versa.  For brevity, we
will refer to both TI BASIC and TI Extended BASIC programs simply as BASIC
programs.</p>

<p>Programs in source format are plain text files that contain the BASIC statements
that a user would usually type in.  These kind of text files are usually not
stored on real TI 99 home computer systems.</p>

<p>Programs in internal format are TI-specific files in <code>PROGRAM</code> format that are
generated by the <code>SAVE</code> command and understood by the <code>OLD</code> and <code>RUN</code> commands.
<code>xbas99</code> also supports programs created in so-called long format <code>INT/VAR 254</code>
and in merge format <code>DIS/VAR 163</code>.</p>

<p>Typical use cases for <code>xbas99</code> include the listing of programs stored in
internal format and the creation of program files for the BASIC interpreter from
a text file with BASIC statements.</p>

<p>The list command <code>-l</code> lists the statements of a BASIC program in internal format on
the screen.  Formatting is identical to the built-in BASIC <code>LIST</code> command modulo
the line wrapping.</p>

<pre><code>$ xbas99.py -l bashello.bin
10 REM HELLO
20 INPUT "YOUR NAME? ":NAME$
30 PRINT "HELLO ";NAME$
40 END
</code></pre>

<p>The similar decode command <code>-d</code> saves the program listing to a file instead:</p>

<pre><code>$ xbas99.py -d bashello.bin
</code></pre>

<p><code>xbas99</code> uses extensions <code>.bas</code> for BASIC programs in source format and <code>.bin</code>
for programs in internal format.  To override the default naming convention, the
<code>-o</code> argument may be used:</p>

<pre><code>$ xbas99.py -d bashello.bin -o sample_program.txt
</code></pre>

<p>BASIC programs in long format are detected automatically.  To list programs in
merge format, simply add the merge option <code>--merge</code>.</p>

<p>(Technical note: On Windows, you currently cannot use <code>xdm99</code> to extract BASIC
programs saved in merge format.  For some unknown reason merge programs are
stored in <code>DIS/VAR</code> format even though they are binary data.  Windows will try
to translate suspected end-of-line markers and thus garble the file contents.)</p>

<p>The create command <code>-c</code> encodes a list of BASIC statements into internal format
so that the resulting file can be loaded and run by the BASIC interpreter on a
TI 99:</p>

<pre><code>$ xbas99.py -c bashello.bas
</code></pre>

<p><code>xbas99</code> assumes that the text file is stored in the native file format of the
host computer.  Each program line should be stored on a separate line, but the
join option <code>-j</code> may be used to automatically join split, i.e., word-wrapped,
lines.</p>

<pre><code>$ xbas99.py -c bashello.txt -j &lt;line-delta&gt;
</code></pre>

<p>Any line that does not begin with a number or whose supposed line number is not
between the previous line number and the previous line number plus <code>line-delta</code>
is considered a continuation of the previous line.</p>

<p>The long option <code>--long</code> instructs <code>xbas99</code> to create the program in long
format.  Long programs are stored within the 32 KB memory expansion and may be
larger than conventional programs.  For petty technical reasons, the creation of
programs in merge format is currently not supported.</p>

<p>The protection option <code>--protect</code> will add list protection to the generated
program.  Programs with list protection cannot be listed or edited by the BASIC
interpreter.  Note, however, that the list command of <code>xbas99</code> will /not/ honor
the protection flag.</p>

<p>Program files created by <code>xbas99</code> are raw <code>PROGRAM</code> files that may have to be
transferred to a disk image or converted to TIFILES format before they can be
used by an emulator or transferred to a real TI 99.  The <code>xdm99</code> tool covers
both of these operations:</p>

<pre><code>$ xdm99.py basic.dsk -a bashello.bin
$ xdm99.py -T bashello.bin
</code></pre>

<p>Advanced users of xdt99 may also combine the creation of the BASIC program file
and the transfer to a disk image in one single step:</p>

<pre><code>$ xbas99.py -c bashello.bas -o - | xdm99.py basic.dsk -a - -n HELLO
</code></pre>

<p>All tools in xdt99 follow the convention that the special filename <code>-</code> denotes
<code>stdin</code> or <code>stdout</code>, respectively.  You can also pipe from <code>xdm99</code> into <code>xbas99</code>
to list BASIC programs quickly that are stored on a disk image:</p>

<pre><code>$ xdm99.py basic.dsk -p HELLO | xbas99.py -l -
</code></pre>

<p>Finally, <code>xbas99</code> does not distinguish between TI BASIC and TI Extended BASIC
programs.  To create a TI BASIC program that does not rely on the TI Extended
BASIC module simply do not use any of the advanced Extended BASIC features such
as <code>::</code> or subprograms like <code>SPRITE</code>.</p>

<p>Also note that the tool will read and encode any text file that you supply, with
only minimal syntax checking.  In other words, the resulting program file should
always load with <code>OLD</code>, but it may not <code>RUN</code>.  A future version of <code>xbas99</code> may
contain more advanced checks to assist developers in creating new BASIC
programs.</p>

<h2>xdm99 Disk Manager</h2>

<p><code>xdm99</code> is a command-line tool for cataloging and manipulating sector-based TI
disk images used by most emulators, including MESS.  <code>xdm99</code> also supports the
TIFiles file format that retains TI-specific meta data for files that originate
from TI disk images.</p>

<h3>Cataloging Disks</h3>

<p>The default operation of <code>xdm99</code> when invoked without any options is to print
the file catalog of the disk image to <code>stdout</code>:</p>

<pre><code>$ xdm99.py ed-asm.dsk
ED-ASSM   :     97 used  263 free   90 KB  1S/1D  40 TpS
----------------------------------------------------------------------------
ASSM1         33  PROGRAM       8192 B            P
ASSM2         18  PROGRAM       4102 B            P
EDIT1         25  PROGRAM       5894 B            P
SAVE          13  DIS/FIX 80    3072 B   36 recs  P
SFIRST/O       3  DIS/FIX 80     512 B    5 recs  P
SLAST/O        3  DIS/FIX 80     512 B    4 recs  P
</code></pre>

<p>The top line shows the name of the disk, the number of used and free sectors as
well as the disk geometry.  For each file, the number of used sectors, the file
type, the file length, the actual number of records, and the protection status
is shown.  If present, the file modification time is also shown.</p>

<p><code>xdm99</code> will warn about any inconsistencies it may find, e.g., blocks claimed by
files but not allocated in the allocation map.  When assembling programs
natively these inconsistencies happen more frequently than one would assume.
Files affected by inconsistencies are flagged with <code>ERR</code> in the catalog.  You
can try the <code>-R</code> option to automatically repair disks with inconsistencies.</p>

<h3>Extracting Files</h3>

<p>The extract parameter <code>-e</code> extracts one or more files from a disk image to the
local file system.</p>

<pre><code>$ xdm99.py work.dsk -e HELLO-S CART-S
</code></pre>

<p>The local output filename is derived automatically from the TI filename but
may be overridden with the <code>-o</code> parameter.</p>

<pre><code>$ xdm99.py work.dsk -e HELLO-S -o hello.a99
</code></pre>

<p>If <code>-o</code> specifies a directory, the output is placed into that directory.</p>

<pre><code>$ xdm99.py work.dsk -e HELLO-O HELLO-S -o hello/
</code></pre>

<p>When extracting two or more files, <code>-o</code> may only be used with a directory
argument.</p>

<p>To print the contents of a file to <code>stdout</code>, the print parameter <code>-p</code> may also
be used:</p>

<pre><code>$ xdm99.py work.dsk -p HELLO-S
</code></pre>

<p>In general, printing files only makes sense for files in DIS/FIX or DIS/VAR
format.  Following Unix conventions, <code>-p</code> is equivalent to combining parameters
<code>-e</code> and <code>-o "-"</code>.</p>

<p>Filenames given by <code>-e</code> may be glob patterns containing wildcards <code>*</code>
and <code>?</code>.  This will extract all files matching the given pattern.</p>

<pre><code>$ xdm99.py work.dsk -e "HELLO-*"
</code></pre>

<p>Note that you may have to quote your glob pattern to prevent your shell from
expanding the pattern prematurely.</p>

<p>By default, <code>xdm99</code> will convert between upper and lower case when moving
PC files to and from disk images.  To keep extracted filenames like they
were on the disk image, use the <code>--ti-names</code> option.</p>

<p>Extracting files will yield the file contents only.  In order to retain file
meta data about file type and record length, use the TIFiles or v9t9 formats
described below.</p>

<h3>Manipulating Disks</h3>

<p>The add parameter <code>-a</code> adds local files to the disk image.  <code>xdm99</code> will infer a
suitable TI filename from the local filename unless an explicit filename is
given by the <code>-n</code> parameter.  If the file is not of type <code>PROGRAM</code>, the file
type must be given using the <code>-f</code> parameter.</p>

<pre><code>$ xdm99.py work.dsk -a ashello.a99 -n HELLO-S -f DIS/VAR80
</code></pre>

<p>The syntax for <code>-f</code> is fairly permissible, e.g., <code>DIS/FIX 80</code>, <code>DISFIX80</code>, or
<code>DF80</code> all work.</p>

<p>When adding multiple files with the <code>-n</code> option, the last character of the
specified filename will be incremented by one for each subsequent file, e.g.,</p>

<pre><code>$ xdm99.py work.dsk -a intro main appendix -n FILE
</code></pre>

<p>will add the files as <code>FILE</code>, <code>FILF</code>, and <code>FILG</code> to the disk image.</p>

<p>The rename parameter <code>-r</code> renames one or more files on the disk.</p>

<pre><code>$ xdm99.py work.dsk -r HELLO-S:HELLO/S
</code></pre>

<p>For each file to rename, provide the old filename, followed by a colon <code>:</code>,
followed by the new filename.</p>

<p>To rename the disk itself, use the <code>-n</code> options without any additional
arguments.</p>

<pre><code>$ xdm99.py work.dsk -n WORK-2
</code></pre>

<p>The delete parameter <code>-d</code> deletes one or more files on the disk.</p>

<pre><code>$ xdm99.py work.dsk -d HELLO-I HELLO-O
$ xdm99.py work.dsk -d "*-O"
</code></pre>

<p>Note that the current implementation of <code>xdm99</code> will actually perform a "secure
erase", i.e., the entire contents of the deleted file will be removed from the
disk image.</p>

<p>The write protection parameter <code>-w</code> toggles the current protection status of
the given files.</p>

<pre><code>$ xdm99.py work.dsk -w HELLO HELLO-CPY
</code></pre>

<p>Note that file protection is solely for TI 99 systems and emulators but will be
ignored by <code>xdm99</code>.</p>

<p>File operations do not retain the overall sector structure of the disk.  In
particular, all files will be defragmented whenever files are added or deleted
with <code>-a</code> or <code>-d</code>, respectively, or when the disk is repaired with <code>-R</code>.  Simply
cataloging the disk, however, will <em>not</em> modify the disk image.</p>

<p>By default, all modifying disk operations will change the disk image directly.
To create an independent copy of the original disk image with the changes
applied, the <code>-o</code> parameter may be used.</p>

<h3>Files in a Directory (FIAD)</h3>

<p>Extracting files from a TI disk image to the local file system will lose certain
TI-specific file information, such as the file type or the record length.  In
order to retain this meta information along with the file contents, the v9t9 and
TIFiles formats were created.  The approach of storing TI files directly on the
local file system instead of using a disk image is also known as "files in a
directory" (FIAD).</p>

<p><code>xdm99</code> supports the TIFiles format and the v9t9 format for FIAD files by using
the <code>-t</code> and <code>-9</code> options, respectively.  To extract a file in either FIAD
format, simply add <code>-t</code> or <code>-9</code> to the extract operation:</p>

<pre><code>$ xdm99.py work.disk -t -e HELLO-S
$ xdm99.py work.disk -9 -e HELLO-S
</code></pre>

<p>By default, files extracted in TIFiles or v9t9 format will have extension <code>.tfi</code>
or <code>.v9t9</code>, respectively.</p>

<p>To add a file in TIFiles format or v9t9 format, add <code>-t</code> or <code>-9</code> to the add
operation:</p>

<pre><code>$ xdm99.py work.disk -t -a hello-s.tfi
$ xdm99.py work.disk -9 -a hello-s.v9t9
</code></pre>

<p>Note that for safety reasons <code>xdm99</code> will not infer the file type automatically,
so adding a FIAD file without <code>-t</code> or <code>-9</code> option will incorrectly store the
file metadata as part of the file contents.</p>

<p>As all information about the TI filename and the TI file format is retrieved
from the FIAD meta data, parameters <code>-n</code> and <code>-f</code> are ignored when used in
combination with <code>-t</code> or <code>-9</code>.</p>

<p><code>xdm99</code> also handles "short" TIFiles used, e.g., by Classic 99.</p>

<pre><code>$ xdm99.py work.disk -t -a HELLO-S
</code></pre>

<p>Short TIFiles do not store TI filename and creation date, but use the host
filesystem information instead.  <code>xdm99</code> detects automatically if a given
TIFiles file is in long or short TIFiles format.</p>

<p>Extracted TIFiles are always in long format, but Classic 99 can use those files
just as well if the extension <code>.tfi</code> is removed.  To simplify exchange with
Classic 99, the <code>--ti-names</code> option will use the uppercase name without
extension.</p>

<p>The info parameter <code>-I</code> displays the meta file information contained in FIAD
files, while the print parameter <code>-P</code> dumps the file contents to <code>stdout</code>:</p>

<pre><code>$ xdm99.py -I hello-s.tfi
$ xdm99.py -P hello-s.v9t9
</code></pre>

<p><code>xdm99</code> can also convert from FIAD files to plain files and vice versa without
relying on disk images using the <code>-T</code> and <code>-F</code> parameters:</p>

<pre><code>$ xdm99.py -F hello-s.tfi
$ xdm99.py -T hello.a99 -f DIS/VAR80 -n HELLO-S -o hello-s.tfi
</code></pre>

<p>Note that creating a FIAD file using the <code>-T</code> option usually requires
information about the TI filename and the TI file type, similar to adding plain
files to a disk image using <code>-a</code>.  When converting multiple files to FIAD
format, the TI filename supplied by <code>-n</code> is incremented automatically for each
file.</p>

<p>FIAD file conversion <code>-T</code>, <code>-F</code> and information <code>-I</code> and <code>-P</code> infer the FIAD
format used automatically, but detection may be overridden with the <code>-t</code> or
<code>-9</code> options.</p>

<h3>Analyzing Disks</h3>

<p>The check parameter <code>-C</code> analyzes a disk image for errors and prints a summary
to <code>stderr</code>.  While all disk operations, including cataloging, also check and
report any disk errors found, the <code>-C</code> parameter restricts the output of <code>xdm99</code>
to those errors only.</p>

<pre><code>$ xdm99.py -C work.dsk
</code></pre>

<p>The <code>-C</code> parameter also causes <code>xdm99</code> to set its return value to non-zero for
warnings, making it simple to write shell scripts for batch processing bad disk
images.</p>

<p>The repair option <code>-R</code> tries to fix any disk errors, mostly by deleting
erroneous files from it.</p>

<pre><code>$ xdm99.py -R work.dsk
</code></pre>

<p>The repair operation is likely to cause data loss, so it's best to extract
erroneous files beforehand or to specify an alternative output file with <code>-o</code>.</p>

<p>The <code>-X</code> or <code>--initialize</code> option creates a new, blank disk image, using an
optional name provided by <code>-n</code>.</p>

<pre><code>$ xdm99.py blank.dsk --initialize 720 -n BLANK
</code></pre>

<p>The size of the disk image is given by the number of sectors.  You may also use
a disk geometry string, which is any combination of the number of sides <code>&lt;n&gt;S</code>,
the density <code>&lt;n&gt;D</code>, and an optional number of tracks <code>&lt;n&gt;T</code>, where <code>&lt;n&gt;</code> is an
integer or the letters <code>S</code> or <code>D</code>.  If <code>&lt;n&gt;T</code> is missing, <code>40T</code> is assumed.</p>

<pre><code>$ xdm99.py blank.dsk -X DSDD
$ xdm99.py blank.dsk -X 1d2s80t
</code></pre>

<p>Note that the disk format used by the TI 99 supports up to 1600 sectors per
disk.</p>

<p>The special geometry <code>CF</code> is used for disk images for the CF7+/nanoPEB devices
and corresponds to 1600 sectors.</p>

<pre><code>$ xdm99.py volume.dsk -X cf
</code></pre>

<p>You can combine <code>-X</code> with other parameters such <code>-a</code> to work with the newly
created image immediately:</p>

<pre><code>$ xdm99.py work.dsk -X SSSD -a file -f DV80
</code></pre>

<p>The resize parameter <code>-Z</code> will change the total number of sectors of
the disk without changing the contents of the files currently stored.</p>

<pre><code>$ xdm99.py work.dsk -Z 720
</code></pre>

<p>An integer argument will not change the geometry information of the disk.  To
change both size and geometry, <code>-Z</code> also accepts a disk geometry string:</p>

<pre><code>$ xdm99.py corcomp.dsk -Z dssd80t -o ti-80t.dsk  # convert to 80 tracks
</code></pre>

<p>Resizing fails if more sectors than the target size are currently in use.</p>

<p>The <code>--set-geometry</code> parameter explicitly sets the number of sides, the
density, and the track information of the disk image.</p>

<pre><code>$ xdm99.py work.dsk --set-geometry 2S1D80T
</code></pre>

<p>The <code>--set-geometry</code> command is rarely required for regular images but may be
helpful for experimenting with non-standard disk image formats.</p>

<p>Note that the 80-track DSDD format is currently not supported.</p>

<p>The sector dump parameter <code>-S</code> prints the hexadecimal contents of individual
sectors to <code>stdout</code>.  This can be used to further analyze disk errors or to save
fragments of corrupted files.</p>

<pre><code>$ xdm99.py work.dsk -S 1
$ xdm99.py work.dsk -S 0x22 -o first-file-sector
</code></pre>

<p>For convenience, integer arguments of <code>-S</code>, <code>-X</code> and <code>-Z</code> may be specified in
either decimal or hexadecimal notation.</p>

<h2>xhm99 HFE Image Manager</h2>

<p>The <code>xhm99</code> HFE image manager is an extension to the <code>xdm99</code> disk manager that
is both a conversion tool and a manager for HFE images used by HxC floppy
emulators.</p>

<h3>Converting Images</h3>

<p>To convert an existing disk image to an HFE image that can be copied onto an SD
card and used by the HxC floppy emulator, invoke <code>xhm99</code> with a single to HFE
<code>-T</code> argument:</p>

<pre><code>$ xhm99.py -T work.dsk [...] [-o &lt;filename&gt;]
</code></pre>

<p>This yields the file <code>work.hfe</code> by default.  Instead of <code>-T</code> you may also use
the long format <code>--to-hfe</code>.</p>

<p>Similarly, the from HFE <code>-F</code> argument converts from HFE image back to disk
image:</p>

<pre><code>$ xhm99.py -F image.hfe [-o &lt;filename&gt;]
</code></pre>

<p>This yields the file <code>image.dsk</code> by default.  Instead of <code>-F</code> you may also use
the long formats <code>--from-hfe</code> or <code>--to-dsk</code>.</p>

<h3>Managing Image Contents</h3>

<p>All options other than <code>-F</code> and <code>-T</code> are similar to those of <code>xdm99</code> and operate
directly on the disk image that is contained in the HFE image supplied.</p>

<p>To show the contents of a HFE image, simply invoke <code>xhm99</code> with the HFE filename
and no further arguments.</p>

<pre><code>$ xhm99.py image.hfe
SOMEDISK  :     4 used  356 free   90 KB  1S/1D 40T  9 S/T
----------------------------------------------------------------------------
SOMEFILE       2  DIS/FIX 60      60 B    1 recs  2016-08-18 20:50:12
</code></pre>

<p>To show the contents of a file on the console, use the print argument <code>-P</code>.</p>

<pre><code>$ xhm99.py image.hfe -p SOMEFILE
Hello xdt99, meet HFE!
</code></pre>

<p>You may also add, extract, rename, or delete files:</p>

<pre><code>$ xhm99.py image.hfe -a manual.txt -f dv80
$ xhm99.py image.hfe -r MANUAL:README
$ xhm99.py image.hfe -e SOMEFILE -o greeting.txt
$ xhm99.py image.hfe -d SOMEFILE
</code></pre>

<p>To create a new HFE image from a single FIAD file, combine the initialize option
<code>-X</code> with the add file argument <code>-a</code> and the TIFiles option <code>-t</code>:</p>

<pre><code>$ xhm99.py new.hfe -X dssd -a somegame.tfi -t
</code></pre>

<p>You can also resize HFE images, e.g., if you want to create more free space:</p>

<pre><code>$ xhm99.py sssd_image.hfe -Z ssdd
</code></pre>

<p>The resize argument <code>-Z</code> can even change the number of tracks, e.g., converting
from DSDD with 40 tracks to DSSD with 80 tracks:</p>

<pre><code>$ xhm99.py dsdd_image.hfe -Z dssd80t
</code></pre>

<p>The only format currently not supported is DSDD80T.</p>

<p>For further information about available arguments please refer to the <code>xdm99</code>
section above.</p>

<h2>xvm99 nanoPEB Volume Manager</h2>

<p>The <code>xvm99</code> volume manager is an extension to the <code>xdm99</code> disk manager that is
both a conversion tool and a manager for CF card volumes used by nanoPEB/CF7+
devices.</p>

<h3>Managing Volumes</h3>

<p>The default operation of <code>xvm99</code> when invoked without any command arguments is
to print a short summary of the disk images stored in the specified volumes.</p>

<pre><code>$ xvm99.py /dev/sdc 1-4,8
[   1]  EXTBASIC  :     4 used  1596 free
[   2]  EMPTY     :     2 used  1598 free
[   3]  SSSD      :    39 used  1561 free
[   4]  INFOCOM   :   459 used  1141 free
[   8]  (not a valid disk image)
</code></pre>

<p>The first argument is the name of your Compact Flash card drive, i.e., something
like <code>/dev/sdc</code> on Linux, <code>/dev/Disk3</code> on Mac OS X, or <code>\\.\PHYSICALDRIVE2</code> on
Windows.  <strong>Caution:</strong> These are examples only; make sure to identify your CF
card device correctly, <em>or you will lose data!</em> Also note that your user needs
appropriate read and/or write permissions to access the device.</p>

<p>On Linux, you can use <code>sudo fdisk -l</code> to find the correct device name of
your memory card, on Windows you can use <code>wmic diskdrive list brief</code> instead.</p>

<p>The second argument may be a single volume number or a combination of value
ranges, e.g., <code>1,3-4,6-10</code>.  In general, if more than one volume is specified,
then the command is applied to <em>all</em> volumes.</p>

<p>The <code>-w</code> argument writes a disk image to one or more volumes.</p>

<pre><code>$ xvm99.py /dev/sdc 1,3 -w work.dsk
</code></pre>

<p><code>xvm99</code> automatically extends the disk image to match the 1600 sector format
used by the CF7+ device, unless the <code>--keep-size</code> option is given.</p>

<p>The <code>-r</code> argument reads a disk image from a volume and stores it on the local
file system.</p>

<pre><code>$ xvm99.py /dev/sdc 2 -r vol2.dsk
</code></pre>

<p>When reading from multiple volumes the resulting disk images will be renamed
automatically.  <code>xvm99</code> trims disk images to match the sector count stored in
the image, unless the <code>--keep-size</code> option is given.</p>

<h3>Manipulating Volumes</h3>

<p>Most commands provided by <code>xdm99</code> are also available for <code>xvm99</code>.</p>

<p>For example, to catalog a volume, you use the same <code>-i</code> command as for <code>xdm99</code>:</p>

<pre><code>$ xvm99.py /dev/sdc 8 -i
</code></pre>

<p>Other commands supported by <code>xvm99</code> are print files <code>-p</code>, extract files <code>-e</code>,
add files <code>-a</code>, delete files <code>-d</code>, check disk <code>-c</code>, and repair disk <code>-R</code>.</p>

<p>Again, if more than one volume is specified, then the command is applied to all
volumes.  For example,</p>

<pre><code>$ xvm99.py /dev/sdc 1-20 -a README -f DV80
</code></pre>

<p>adds the local file README to all disk images in volumes 1 through 20.</p>

<h2>Example Usage</h2>

<p>This section gives an example on how to assemble a TI 99 assembly program and
run it on the MESS emulator.  The commands entered and the responses shown here
originate from a Linux system, but they should look very similar on Windows and
Mac OS X machines.</p>

<p>The binary distribution of xdt99 contains an <code>example</code> folder with some sample
files that we're going to use.  For the source distribution available on Github
these files are located under the <code>test</code> folder.</p>

<pre><code>$ cd example/
$ ls -l
-rw-rw---- 1 ralph ralph  1822 Jan 10 12:51 ascart.a99
-rw-rw---- 1 ralph ralph   925 Jan 10 12:32 ashello.a99
-rw-rw---- 1 ralph ralph 92160 Jan 10 12:33 work.dsk
</code></pre>

<p>The file <code>ashello.a99</code> contains a simple assembly program that we want to
assemble and run.  Since the program uses register symbols like <code>R0</code> to refer
to registers, we need to specify the <code>-R</code> option for assembly.</p>

<pre><code>$ xas99.py -R ashello.a99
</code></pre>

<p>This should yield an object code file <code>ashello.obj</code> that looks like
this:</p>

<pre><code>0007EASHELLO A0000B100DB4845B4C4CB4F20B574FB524CB4420B2020B68697F19FF       0001
A0012B7420B616EB7920B6B65B7921B0300B0000B02E0B8300B04C0B02017F2F9F          0002
A0028B2A20B0202B0300B0420B0000B0580B0602B16FBB0200B0043B02017F336F          0003
A003EC0002B0202B001AB0420B0000B0208BFF00B04C9B0300B0002B10007F31FF          0004
A0054B0300B0000BD809B837CBD809B8374B0420B0000B9220B8375B13F97F2D4F          0005
A006ABD020B8375B0980B0240B000FB0260B0700B0420B0000B10E87F410F               0006
50000SLOAD 50000SFIRST5007ESLAST 5001CSTART 30030VSBW  7F28AF               0007
30046VMBW  3007AVWTR  30062KSCAN 7F827F                                     0008
:       xdt99 xas                                                           0009
</code></pre>

<p>This file can be loaded with the Editor/Assembler module using option 3, or
alternatively with the TI Extended BASIC module using the <code>CALL LOAD</code>
statement.</p>

<p>Uncompressed object code is not an efficient program format, though.  If
compatibility with Extended BASIC is not required, compressed object code
reduces both size and loading time:</p>

<pre><code>$ xas99.py -R -C ashello.a99 - ashello-c.obj
</code></pre>

<p>Comparing both object files we see that the compressed version is only about
two thirds of the size of the uncompressed file:</p>

<pre><code>$ ls -l ashello*.obj
-rw-rw---- 1 user user 486 Jul 12 09:58 ashello-c.obj
-rw-rw---- 1 user user 729 Jul 12 09:58 ashello.obj
</code></pre>

<p>To save even more space, we'll also generate an image file for option 5:</p>

<pre><code>$ xas99.py -R -i ashello.a99
</code></pre>

<p>This time we should get a binary file <code>ashello.img</code> of 132 bytes.</p>

<pre><code>$ ls -l ashello.img
-rw-rw---- 1 ralph ralph   132 Jan 10 13:11 ashello.img
</code></pre>

<p>We now need to transfer these files to a TI disk image so that the TI 99
emulated by MESS can load it.  We'll use the SS/SD disk image <code>work.dsk</code> that
is included in the example folder of xdt99 for convenience:</p>

<pre><code>$ xdm99.py work.dsk -a ashello.obj -n HELLO-O -f DIS/FIX80
$ xdm99.py work.dsk -a ashello.img -n HELLO-I
$ xdm99.py work.dsk
WORK      :     8 used  352 free   90 KB  1S/1D  40 TpS
----------------------------------------------------------------------------
HELLO-I        2  PROGRAM        132 B            2015-01-10 13:15:18
HELLO-O        4  DIS/VAR 80     755 B    9 recs  2015-01-10 13:15:10
</code></pre>

<p>We start MESS with our work disk inserted in floppy drive 1:</p>

<pre><code>$ mess64 ti99_4ae -peb:slot2 32kmem -peb:slot8 hfdc -cart EA.rpk -flop1 work.dsk
</code></pre>

<p>You may have to adjust the command for starting MESS based on the location of
your Editor/Assembler cartridge file.  When using a graphical frontend to launch
MESS, use your GUI to select the Editor/Assembler module and the disk image
previously created.</p>

<p>On the TI 99/4A startup screen, we hit any key, then select the Editor/Assembler
module.  We select option 3, <code>LOAD AND RUN</code>, then enter the name of the object
code file at the <code>FILE NAME?</code> prompt:</p>

<pre><code>DSK1.HELLO-O
</code></pre>

<p>Once the loader finishes, we hit <code>ENTER</code> to advance to the <code>PROGRAM NAME?</code>
prompt, and type <code>START</code> to start the program.  The words "HELLO WORLD" should
appear on screen, and hitting any key will change the color of the screen
border.</p>

<p>When done, we quit the program by hitting <code>FCTN =</code>.  Again we select the
Editor/Assembler module, but now we select option 5, <code>RUN PROGRAM FILE</code>.  We
enter the name of the image file:</p>

<pre><code>DSK1.HELLO-I
</code></pre>

<p>The program will start automatically once loading has completed.</p>

<p>If we want to learn more about the internals of our assembled program we can
take a look at its list file:</p>

<pre><code>$ xas99.py -R ashello.a99 -L ashello.lst
</code></pre>

<p>This yields a text file <code>ashello.lst</code> that begins like this:</p>

<pre><code>XAS99 CROSS-ASSEMBLER   VERSION 1.2.3
0001            *  HELLO WORLD
0002
0003                   IDT 'ASHELLO'
0004
0005                   DEF SLOAD,SFIRST,SLAST,START
0006                   REF VSBW,VMBW,VWTR
0007                   REF KSCAN
0008
0009            SLOAD
0010 0000 100D  SFIRST JMP  START
0011
0012      8300  WRKSP  EQU  &gt;8300
0013      8374  KMODE  EQU  &gt;8374
0014      8375  KCODE  EQU  &gt;8375
0015      837C  GPLST  EQU  &gt;837C
0016
0017 0002 ....  MESSG  TEXT 'HELLO WORLD'
0018 000D ....         TEXT '   hit any key!'
0019      001A  MESSGL EQU  $-MESSG
0020
0021 001C 0300  START  LIMI 0
     001E 0000
0022 0020 02E0         LWPI WRKSP
     0022 8300
...
</code></pre>

<p>The first column shows the line number of our source file.  As we can see, some
source file lines may produce more than one list file lines.  The second and
third columns show the memory location and its contents, respectively.  Some
directives such as <code>EQU</code> do not correspond to a memory location, so their
second and third columns may show other relevant information instead.</p>

<p>To run assembly programs without the Editor/Assembler module, we finally
generate our own self-contained cartridge.</p>

<p>First we need to assemble our source code using the <code>-c</code> option.</p>

<pre><code>$ xas99.py -R -c ascart.a99 -n "HELLO CART"
</code></pre>

<p>Note that we cannot run the <code>ashello.a99</code> program as a cartridge, since we call
<code>VSBW</code> and other VDP subroutines, which are unavailable without Editor/Assembler
module and memory expansion.  The <code>ascart.a99</code> program thus uses the VDP
registers directly to write to VDP memory.</p>

<p>We don't have to transfer the resulting RPK file to a disk image but can plug
the cartridge directly into the MESS emulator:</p>

<pre><code>$ mess64 ti99_4ae -cart ascart.rpk
</code></pre>

<p>After pressing any key on the TI 99 startup screen you should now see "HELLO
CART" as the second option on the menu screen.  Pressing 2 will run the sample
program.</p>

<p>Note that the programs runs without the 32K memory expansion, as the
program code is stored inside a virtual cartridge ROM.</p>

<p>If we want to run our sample program on a real TI 99 using the CF7+ flash drive,
we need to transfer our disk image to a flash card first:</p>

<pre><code>$ xvm99.py /dev/sdc 2 -w work.dsk
</code></pre>

<p>This will make our work disk from above available as volume 2 on the CF7+, where
it can be accessed as <code>DSK2</code> by default on the TI 99.  If we don't want to
replace the entire disk contents of volume 2 we could also just transfer the
file instead.</p>

<pre><code>$ xvm99.py /dev/sdc 2 -a ashello.obj -n HELLO-O -f DIS/FIX80
</code></pre>

<p>Either way, <code>ashello.obj</code> will be available as <code>HELLO-O</code> in volume 2 and can
loaded as <code>DSK2.HELLO-O</code> by the Editor/Assembler module.</p>

<h3>Building Cartridges With GPL</h3>

<p>This subsection shows how we can use the <code>xga99</code> GPL cross-assembler to assemble
GPL programs into virtual cartridges that run in any TI 99 emulator.  (With the
right device such as a GRAM Kracker this exercise would even work on a physical
TI computer!)</p>

<p>The <code>example/</code> directory included with xdt99 contains a small GPL program
<code>gahello.gpl</code> that sets some sprites in motion, shows a simple animation in
normal graphics mode, and plays a simple tune.</p>

<p>If you're using the MESS emulator running the sample program is very easy:</p>

<pre><code>$ xga99.py -c gahello.gpl
$ mess64 ti99_4ae -cart gahello.rpk
</code></pre>

<p>Inside the TI 99 emulation, you'll find a menu entry for the cartridge program
on the TI menu selection screen.</p>

<p>For other emulators you'll probably need to work with the plain GPL image file
instead:</p>

<pre><code>$ xga99.py -i gahello.gpl -G 0x6000 -A 0x20
</code></pre>

<p>This yields the file <code>gahello.bin</code> that contains the GPL byte code with suitable
header data for the GPL interpreter of the TI 99.  The <code>-G</code> and <code>-A</code> options
tell <code>xga99</code> that we want to place the byte code into a cartridge GROM.</p>

<p>To run the sample program, load <code>gahello.bin</code> as a cartridge into your emulator
and reset the virtual TI 99.  Again, you should find an entry for the program on
the TI menu selection screen.</p>

<h2>Feedback and Bug Reports</h2>

<p>The xdt99 tools are released under the GNU GPL, in the hope that TI 99
enthusiasts may find them useful.</p>

<p>Please email feedback and bug reports to the developer at <a href="&#109;&#97;&#105;&#x6C;&#116;&#x6F;:&#120;&#100;&#x74;&#x39;&#x39;&#100;&#101;&#118;&#64;&#x67;&#109;&#x61;&#105;&#x6C;&#x2E;&#99;&#x6F;&#x6D;">&#120;&#100;&#x74;&#x39;&#x39;&#100;&#101;&#118;&#64;&#x67;&#109;&#x61;&#105;&#x6C;&#x2E;&#99;&#x6F;&#x6D;</a>
or use the issue tracker on the project <a href="https://github.com/endlos99/xdt99">GitHub page</a>.</p>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">xdt99  Copyright (C) 2015-2019 R. Benzinger</a></p>
      </footer>
    </div>

  </body>
</html>
